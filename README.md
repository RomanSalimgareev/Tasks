# Задачи по алгоритмам
Условия задач были взяты с курса https://stepik.org/course/64454/syllabus
(Индексы файлов "_x" подразумевают не этап в подблоке на сайте, а именно номер 
задачи по счету в этапе. Например 1.2_6 - 6 задача по счету в подблоке 1.2)

## Задачи:

A. [20k20](#a-20k20)

B. [Веревочки](#b-Веревочки)

C. [Подсчет суммы](#c-Подсчет-суммы)

D. [КузнечиК](#d-КузнечиК)

E. [Путь Ферзя](#e-Путь-Ферзя)

F. [Рюкзак5](#f-Рюкзак5)

G. [Проверка обхода в глубину](#g-Проверка-обхода-в-глубину)

H. [Поиск цикла](#h-Поиск-цикла)

I. [Проверка топологической сортировки](#i-Проверка-топологической-сортировки)

J. [(p,q)-лошадь](#j-(p,q)-лошадь)

K. [Выведите, пожалуйста, утку](#k-Выведите,-пожалуйста,-утку)

## Условия задач и тестовые примеры

### A. 20k20
Владислав заметил, что в 2020-м году целых две пары одинаковых символов - 2 и 0.
На основании этого он возненавидел цифры 2 и 0, а также ситуацию, когда в году
есть одинаковые цифры. Сейчас Владислав ждет следующего года, в котором нет 
цифр 2 и 0, а также все цифры попарно различны. Посчитайте, в каком году это
случится первый раз?

#### Входные данные:
В первой строке входных данных записано единственное целое число _n_ (1 ⩽ _n_ ⩽ 10<sup>9</sup>)

#### Выходные данные:
Выведите одно число - следующий год, в котором все цифры попарно различны,
а также нет цифр 2 и 0. Если больше такого года никогда не будет,
выведите <<-1>> (без кавычек).

Sample Input 1:
---------------
	2020
	
Sample Output 1:
----------------
	3145
	
Sample Input 2:
---------------
	1982
	
Sample Output 2:
----------------
	

### B. Веревочки
С утра шел дождь, и ничего не предвещало беды. Но к обеду выглянуло солнце,
и в лагерь заглянула СЭС. Пройдя по всем домикам и корпусам, СЭС вынесла
следующий вердикт: бельевые веревки в жилых домиках не удовлетворяют нормам СЭС.
Как выяснилось, в каждом домике должно быть ровно по одной бельевой веревке,
и все веревки должны иметь одинаковую длину.
В лагере имеется _N_ бельевых веревок и _K_ домиков. Чтобы лагерь не закрыли,
требуется так нарезать данные веревки, чтобы среди получившихся веревочек было _K_
одинаковой длины. Размер штрафа обратно пропорционален длине бельевых веревок,
которые будут развешены в домиках. Поэтому начальство лагеря стремиться
максимизировать длину этих веревочек

#### Входные данные:
В первой строке заданы два числа - _N_ (1 ⩽ _N_ ⩽ 10001) и _K_ (1 ⩽ _K_ ⩽ 10001). 
Далее в каждой из последующих _N_ строк записано по одному числу - длине очередной
бельевой веревки. Длина веревки задана в сантиметрах. Все длины лежат в интервале
от 1 сантиметра до 100 километров включительно.

#### Выходные данные:

В выходной файл следует вывести одно целое число - максимальную длину веревочек,
удовлетворяющую условию, в сантиметрах. В случае, если лагерь закроют, выведите 0.

#### Sample Input:
	4 11
	802
	743
	457
	539
	
#### Sample Output:
	200

### C. Подсчет суммы
![formula](https://latex.codecogs.com/svg.image?\color{white}\Large\sum_{k=1}^{l}C_{n}^{mk}\bmod10^9+7)

Напомним, что
![formula](https://latex.codecogs.com/svg.image?\color{white}\Large%20C_%7Bn%7D%5E%7Bmk%7D%20%3D%20%5Cfrac%7Bn%21%7D%7B%28n-mk%29%21%28mk%29%21%7D)

а в случае ( _n_ < _mk_ ) следует считать, что

![formula](https://latex.codecogs.com/svg.image?\color{white}\Large%20C_%7Bn%7D%5E%7Bmk%7D%3D0)

На вход подаются три целых числа _n_,  _m_, и _l_ (1 ⩽ _n_, _m_, _l_ ⩽ 10<sup>6</sup>)

#### Sample Input 1:
	3 1 3
	
#### Sample Output 1:
	7
	
#### Sample Input 2:
	3 4 5
	
#### Sample Output 2:
	0

### D. КузнечиК
Перед клетчатой полоской длины _n_ сидит кузнечик. Каждая клетка является либо
занятой, либо свободной. Кузнечик умеет прыгать на 1, 2, … _k_ клеток вперед.
Найдите количество различных путей, которыми он может добраться до последней клетки,
не заходя в занятые.

#### Входные данные:
В первой строке записано два целых числа _n_, _k_ (1 ≤ k ≤ n ≤5 ⋅ 10<sup>5</sup>).
Во второй строке записана строка длины _n_, состоящая только из нулей и единиц.
Ноль обозначает свободную клетку, а единица - занятую.

#### Выходные данные:
Выведите единственное число - количество способов добраться до последней клетки.
Поскольку это число может быть очень большим, выведите его по модулю 10<sup>9</sup> + 7

#### Sample Input 1:
	8 3
	01100010
	
#### Sample Output 1:
	3
	
#### Sample Input 2:
	8 3
	00000001
	
#### Sample Output 2:
	0
	
### E. Путь Ферзя
В верхней левой клетке доски сидит ферзь. Он умеет ходить на любое количество клеток
вправо и вниз, а также на любое количество клеток по диагонали вниз-вправо. Необходимо
посчитать количество способов, которыми этот ферзь  может добраться до нижней правой
клетки доски.

#### Входные данные:
Входные данные содержат два целых числа _n_, _m_ (1 ≤ _n_, _m_ ≤ 1500) - количество
строк и столбцов в таблице

#### Выходные данные:
Выведите единственное число - количество способов добраться до нижней правой клетки.
Поскольку это число может быть очень большим, выведите его по модулю 10<sup>9</sup> + 7

#### Sample Input 1:
	2 3
	
#### Sample Output 1:
	7
	
#### Sample Input 2:
	3 3
	
#### Sample Output 2:
	22

### F. Рюкзак5
У вас есть _n_ слитков золота, каждый имеет свой вес и стоимость. Также у вас есть рюкзак
вместимости _S_. Необходимо вычислить максимальную суммарную стоимость слитков, которую вы
можете получить. Вы не можете дробить слитки.

#### Входные данные:
Входные данные содержат два целых числа _n_, _m_ (1 ≤ _n_, _m_ ≤ 1500) - количество
строк и столбцов в таблице

#### Выходные данные:
Выведите единственное число - количество способов добраться до нижней правой клетки.
Поскольку это число может быть очень большим, выведите его по модулю 10<sup>9</sup> + 7

#### Sample Input:
	2 3
	
#### Sample Output:
	7

### G. Проверка обхода в глубину
В этой задаче вам требуется проверить, что данный набор ребер может образовывать
дерево обхода в глубину.

#### Входные данные:
В первой строке записано два целых числа _n_, _m_ (1 ≤ _n_ ≤ 500; 0 ≤ _m_ ≤ $\frac{n(n-1)}{2}$) - количество
вершин и количество ребер. В следующих m строках описаны ребра графа.
Каждое ребро задается двумя числами _u_, _v_ (1 ≤ _u_, _v_ ≤ _n_; $u \neq v$) - номера концов ребра.
Гарантируется, что каждое ребро описано в графе единожды. Граф не ориентирован.

Далее записано число (0 ≤ _q_ ≤ _m_) - количество выбранных ребер.

В следующей строке записано q чисел - номера ребер в выбранном множестве.
Гарантируется, что все номера различны и лежат в промежутке 1 … _m_. Ребра нумеруются
в том порядке, в котором они даны во входных данных.

#### Выходные данные:
В единственной строке выведите "YES"" (без кавычек), если данное множество ребер может 
образовывать дерево обхода в глубину и "NO" (без кавычек) иначе.

#### Sample Input 1:
	10 14
	5 6
	7 6
	3 1
	2 7
	10 2
	10 8
	7 9
	10 1
	4 8
	1 4
	6 1
	2 8
	7 8
	9 6
	10
	14 10 11 8 2 4 6 3 9 12
	
#### Sample Output 1:
	NO

#### Sample Input 2:
	6 10
	5 3
	4 6
	1 2
	6 5
	3 2
	6 1
	1 4
	1 3
	2 6
	1 5
	5
	9 1 7 4 8
	
#### Sample Output 2:
	YES
	
### H. Поиск цикла
Дан ориентированный граф, требуется найти любой цикл в нем, либо сказать, что их нет.

#### Входные данные:
В первой строке записано два целых числа _n_, _m_ (1 ≤ _n_ ≤ 500; 0 ≤ _m_ ≤ _n_<sup>2</sup>) - количество
вершин и количество ребер.

В следующих _m_ строках описаны ребра графа. Каждое ребро задается двумя числами
 _u_, _v_ (1 ≤ _u_, _v_ ≤ _n_) - номера стартовой и финишной вершин ребра. Гарантируется, что
каждое ребро описано в графе единожды.

#### Выходные данные:
Если в описанном графе нет циклов, в единственной строчке выведите "NO" (без кавычек).

Иначе в первой строке выведите "YES" (без кавычек).

Во второй строке выведите единственное число _q_ - количество вершин на цикле.

В третьей строке выведите номера вершин, образующих цикл. Каждая вершина должна быть
достижима из предыдущей переходом ровно по одному ребру, а также должно существовать
ребро из последней вершины в первую. Если существует несколько циклов, выведите любой.

#### Sample Input 1:
	4 4
	1 2
	2 3
	3 4
	4 1
	
#### Sample Output 1:
	YES
	4
	1 2 3 4

#### Sample Input 2:
	4 4
	1 2
	2 3
	3 4
	1 4
	
#### Sample Output 2:
	NO
	
### I. Проверка топологической сортировки
В этой задаче дан ориентированный граф и некоторый порядок вершин. Требуется проверить,
что вершины, следующие в данном порядке образуют топологическую сортировку.

#### Входные данные:
В первой строке записано два целых числа _n_, _m_ (1 ≤ _n_ ≤ 2⋅10<sup>5</sup>; 0 ≤ _m_ ≤ 2⋅10<sup>5</sup> ) - количество
вершин и количество ребер.

В следующих m строках описаны ребра графа. Каждое ребро задается двумя числами 
_u_, _v_ (1 ≤ _u_, _v_ ≤ _n_) - номера стартовой и финишной вершин ребра. Гарантируется, что каждое
ребро описано в графе единожды.

В последней строке записано _n_ различных чисел, каждое от 1 до _n_ - номера вершин в выбранном порядке.

#### Выходные данные:
В единственной строке выведите "YES" (без кавычек), если данный порядок является
топологической сортировкой и "NO" (без кавычек) иначе.

#### Sample Input 1:
	5 6
	1 4
	5 5
	1 3
	1 5
	5 1
	5 4
	4 5 1 2 3
	
#### Sample Output 1:
	NO

#### Sample Input 2:
	5 8
	5 4
	2 3
	5 3
	2 1
	4 2
	5 2
	4 1
	5 1
	5 4 2 3 1
	
#### Sample Output 2:
	YES

### J. (p,q)-лошадь
(_p_, _q_)-лошадь - это обобщение обычного шахматного коня. (_p_, _q_)-лошадь своим ходом 
перемещается на _p_ клеток в одном направлении, и на _q _ - в другом (перпендикулярном).
Например, (3,4)-лошадь может переместиться с клетки (5,6) на клетки (1,3), (2,2), 
(2,10), (1,9), (8,10), (9,9), (8,2) и (9,3). Очевидно, что обычный шахматный конь - это
(2,1)-лошадь.

Ваша задача - определить минимальное число ходов, которое требуется (_p_, _q_)-лошади,
чтобы добраться от одной клетки шахматной доски _M_ × _N_ до другой. За пределы доски
выходить запрещается.

#### Входные данные:
Единственная строчка во входном файле содержит 8 целых чисел 
_M_, _N_, _p_, _q_, x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>
​(1 ≤ x<sub>1</sub>, x<sub>2</sub> ≤ _M_ ≤ 100, 1 ≤ y<sub>1</sub>, y<sub>2</sub> ≤ _N_ ≤ 100, 0 ≤ _p_ ≤ 100, 0 ≤ _q_ ≤ 100).

#### Выходные данные:
Первая строка выходного файла должна содержать целое число _k_ - число ходов, которое требуется 
(_p_, _q_)-лошади, чтобы добраться из клетки (x<sub>1</sub>, y<sub>1</sub>) в клетку (x<sub>2</sub>, y<sub>2</sub>). Если (_p_, _q_)-лошадь не может
добраться из (x<sub>1</sub>, y<sub>1</sub>) в (x<sub>2</sub>, y<sub>2</sub>), выведите в выходной файл единственное число −1. 

#### Sample Input 1:
	3 3 1 1 1 1 3 3
	
#### Sample Output 1:
	2

#### Sample Input 2:
	2 2 1 1 1 1 1 2
	
#### Sample Output 2:
	-1

### K. Выведите, пожалуйста, утку
Как-то профессор Налейпиво заметил, что один из студентов на его лекции уделяет слишком 
много внимания мобильному телефону. Подкравшись сзади (а несмотря на большие размеры,
профессор Налейпиво умеет незаметно подкрадываться), профессор обнаружил смягчающее вину
студента обстоятельство - тот не отправлял SMS-ки, а увлечённо играл в следующуюигру.

Есть поле размером _N_ × _M_ ячеек и несколько (возможно ноль) стен между ячейками.
Одна из ячеек является стоком, в то время как одна из оставшихся занята уткой. Ваша задача
привести утку в сток. Единственный способ передвижения утки, доступный вам - это скольжение,
что подразумевает, что вы можете толкнуть утку в одном из четырёх направлений, и она будет
скользить в нем, пока не упрется в стену. Вы не можете толкнуть утку снова, пока она не
остановится. Уровень считается пройденным, если утка останавливается в стоке.
Если утка просто проскользнула через сток, не остановившись, уровень не считается пройденным.

Профессор остановил лекцию и попросил студента создать несколько своих уровней. Он расчертил
на доске уровень, нанёс стены, поместил сток, и теперь студенту надо разместить где-то утку.
Профессор выбрал несколько мест, куда бы он хотел поместить её, и  предложилстуденту описать
алгоритм прохождения уровня. Студент быстро понял, что это ловушка - среди них есть такие,
начав игру из которых, довести утку до стока невозможно. А сумеете ли это сделать Вы?
Ваша задача - имея размеры поля, позицию стен и стока, а также выбранные позиции для утки,
найти среди выбранных позиций такие, начав игру из которых пройти уровень возможно.

#### Входные данные:
Первая строка содержит два числа _N_ и _M_ - размеры поля.

Далее следует 2 _N_ + 1 строк, каждая по 2 _M_ + 1 символов, где 2 _k_-ый символ 
2 _i_-ой стоки либо пробел, если ячейка пуста, либо _S_ если ячейка содержит сток либо 
_D_ если ячейка входит в список выбранных для размещения утки.

(2 _k_ + 1)-ый символ 2 _i_-ой строки либо пробел, если _k_ > 0 и _k_ < _M_ и нет стены между
ячейками (_k_, _i_) и 
(_k_ + 1, _i_); либо | в противном случае.

2 _k_-ый символ (2 _i_ + 1)-ой строки либо пробел, если _i_ > 0 и _i_ < _N_ и нет стены между
ячейками (_k_, _i_) и
(_k_, _i_ + 1); либо - в противном случае.

(2 _k_ + 1)-ый символ (2 _i_ + 1)-ой строки всегда +.

1 ≤ _N_ ≤ 1000

1 ≤ _M_ ≤ 1000

#### Выходные данные:
Выведите поле из входного файла, заменив буквы D на пробел в ячейках, начиная с которых,
нельзя пройти уровень.

#### Sample Input:
	5 5
	+-+-+-+-+-+
	|         |
	+ +-+ + + +
	|  S   D D|
	+ + + + + +
	|    D  | |
	+ + + + + +
	| |     | |
	+ + + +-+ +
	|         |
	+-+-+-+-+-+
	
#### Sample Output:
	+-+-+-+-+-+
	|         |
	+ +-+ + + +
	|  S   D  |
	+ + + + + +
	|    D  | |
	+ + + + + +
	| |     | |
	+ + + +-+ +
	|         |
	+-+-+-+-+-+